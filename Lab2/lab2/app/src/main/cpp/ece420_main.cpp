//
// Created by daran on 1/12/2017.
//

#include "ece420_main.h"
#define FRAME_SIZE 128

// TODO: Change this to match your filter
#define N_TAPS 191

int16_t firFilter(int16_t sample);

void ece420ProcessFrame(sample_buf *dataBuf) {
    // Keep in mind, we only have a small amount of time to process each buffer!
    struct timeval start;
    struct timeval end;
    gettimeofday(&start, NULL);

    // Using {} initializes all values in the array to zero
    int16_t bufferIn[FRAME_SIZE] = {};
    int16_t bufferOut[FRAME_SIZE] = {};


    // ******************** START YOUR CODE HERE ********************

    // Your buffer conversion here
    int i = 1;
    for(int binIdx = 0; binIdx < FRAME_SIZE; binIdx++)
    {
        uint16_t MSbyte = dataBuf->buf_[i];
        uint16_t LSbyte = dataBuf->buf_[i - 1];
        MSbyte = MSbyte << 8;
        int16_t sample = MSbyte + LSbyte;
        bufferIn[binIdx] = sample;
        i = i+2;
    }
    // Loop code provided as a suggestion. This loop simulates sample-by-sample processing.
    for (int sampleIdx = 0; sampleIdx < FRAME_SIZE; sampleIdx++) {
        int16_t sample = bufferIn[sampleIdx];

        // Your function implementation
        int16_t output = firFilter(sample);

        bufferOut[sampleIdx] = output;
    }

    // Your buffer conversion here
    i = 0;
    for(int boutIdx = 0; boutIdx < FRAME_SIZE; boutIdx++)
    {

        uint8_t LSByte = bufferOut[boutIdx];

        uint16_t MSByteShift = bufferOut[boutIdx] - LSByte;
        uint8_t MSByte = MSByteShift >> 8;

        dataBuf->buf_[i] = LSByte;
        dataBuf->buf_[i+1] = MSByte;
        i = i + 2;
    }

    // ********************* END YOUR CODE HERE *********************



    gettimeofday(&end, NULL);
    LOGD("Loop timer: %ld us",  ((end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec)));

}


int16_t circBuf[N_TAPS] = {};
int16_t circBufIdx = 0;
int circBufIdx_next = 0;

int16_t firFilter(int16_t sample) {
    int16_t output = 0;

    // This function simulates sample-by-sample processing. Here you will
    // implement an FIR filter such as:
    //
    // y[n] = a x[n] + b x[n-1] + c x[n-2] + ...
    //
    // You will maintain a circular buffer to store your prior samples
    // x[n-1], x[n-2], ..., x[n-k]. Suggested initializations circBuf
    // and circBufIdx are given.
    //
    // Input 'sample' is the current sample x[n].
    // ******************** START YOUR CODE HERE ********************
    float coefs[] = {-0.00630008287337, -0.00596571224294, -0.00536308113804, -0.00452831974594, -0.0035136399968, -0.00238370362366, -0.0012109813963, -7.04369124681e-05, 0.000966072702624, 0.0018352565236, 0.00248728859386, 0.00288975782863, 0.00303034499241, 0.00291799273512, 0.00258244465905, 0.00207215141432, 0.00145066689015, 0.000791776252058, 0.000173700712022, -0.000327196688266, -0.000642730940383, -0.000718752964384, -0.000520080367259, -3.4094267117e-05, 0.00072731383546, 0.00172764401573, 0.00290760226019, 0.00418874695201, 0.00547874567684, 0.00667789180694, 0.00768642451776, 0.00841212155448, 0.00877759761356, 0.00872674639174, 0.00822981192209, 0.00728666236557, 0.00592796152029, 0.00421408179925, 0.00223176698686, 8.87219248634e-05, -0.00209353302386, -0.00418806448311, -0.00607159817231, -0.00763360438479, -0.0087847182616, -0.00946384348073, -0.00964336417516, -0.00933201095384, -0.00857508529808, -0.00745193188355, -0.00607074782733, -0.00456101738658, -0.00306404574688, -0.00172222237277, -0.000667760738979, -1.17274752841e-05, 0.000165816278389, -0.000176212349134, -0.00103449833582, -0.00235897179249, -0.00405382352956, -0.00598197447283, -0.00797283791553, -0.00983297415175, -0.0113590173418, -0.01235207045, -0.0126326296456, -0.0120550254567, -0.0105203611086, -0.0079869912786, -0.00447771464211, -8.3044079592e-05, 0.00503984203693, 0.0106725903605, 0.0165454374895, 0.0223507941172, 0.0277599273033, 0.0324417939357, 0.0360829086963, 0.0384070286596, 0.0391934122211, 0.038292465575, 0.0356377233948, 0.0312533144831, 0.0252563259171, 0.0178537845617, 0.00933430366051, 5.47736508392e-05, -0.00957721092305, -0.0191242228473, -0.028141989845, -0.036203171051, -0.0429205313841, -0.04796814535, -0.0510993696758, 0.947839488948, -0.0510993696758, -0.04796814535, -0.0429205313841, -0.036203171051, -0.028141989845, -0.0191242228473, -0.00957721092305, 5.47736508392e-05, 0.00933430366051, 0.0178537845617, 0.0252563259171, 0.0312533144831, 0.0356377233948, 0.038292465575, 0.0391934122211, 0.0384070286596, 0.0360829086963, 0.0324417939357, 0.0277599273033, 0.0223507941172, 0.0165454374895, 0.0106725903605, 0.00503984203693, -8.3044079592e-05, -0.00447771464211, -0.0079869912786, -0.0105203611086, -0.0120550254567, -0.0126326296456, -0.01235207045, -0.0113590173418, -0.00983297415175, -0.00797283791553, -0.00598197447283, -0.00405382352956, -0.00235897179249, -0.00103449833582, -0.000176212349134, 0.000165816278389, -1.17274752841e-05, -0.000667760738979, -0.00172222237277, -0.00306404574688, -0.00456101738658, -0.00607074782733, -0.00745193188355, -0.00857508529808, -0.00933201095384, -0.00964336417516, -0.00946384348073, -0.0087847182616, -0.00763360438479, -0.00607159817231, -0.00418806448311, -0.00209353302386, 8.87219248634e-05, 0.00223176698686, 0.00421408179925, 0.00592796152029, 0.00728666236557, 0.00822981192209, 0.00872674639174, 0.00877759761356, 0.00841212155448, 0.00768642451776, 0.00667789180694, 0.00547874567684, 0.00418874695201, 0.00290760226019, 0.00172764401573, 0.00072731383546, -3.4094267117e-05, -0.000520080367259, -0.000718752964384, -0.000642730940383, -0.000327196688266, 0.000173700712022, 0.000791776252058, 0.00145066689015, 0.00207215141432, 0.00258244465905, 0.00291799273512, 0.00303034499241, 0.00288975782863, 0.00248728859386, 0.0018352565236, 0.000966072702624, -7.04369124681e-05, -0.0012109813963, -0.00238370362366, -0.0035136399968, -0.00452831974594, -0.00536308113804, -0.00596571224294, -0.00630008287337};

    circBuf[circBufIdx] = sample;

    circBufIdx = circBufIdx_next;
    circBufIdx_next = (circBufIdx + 1) % N_TAPS;
    circBuf[circBufIdx] = sample;
    for (int i = 0; i < N_TAPS; ++i)
    {
        output += coefs[i]*circBuf[circBufIdx];
        circBufIdx = (circBufIdx + N_TAPS - 1) % N_TAPS;

    }


    circBufIdx = (circBufIdx + 1 + N_TAPS) % N_TAPS;
    // ********************* END YOUR CODE HERE *********************

    return output;
}
